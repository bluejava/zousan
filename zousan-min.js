!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).Zousan=e()}(this,function(){"use strict";const t=void 0,e=t,n=(()=>{const e=[],n=1024;let c=0;function i(){for(;e.length-c;){try{e[c]()}catch(t){o.error(t)}e[c++]=t,c==n&&(e.splice(0,n),c=0)}}const r=(()=>{if("undefined"!=typeof MutationObserver){const t=document.createElement("div");return new MutationObserver(i).observe(t,{attributes:!0}),function(){t.setAttribute("a",0)}}return"undefined"!=typeof process&&"function"==typeof process.nextTick?function(){process.nextTick(i)}:"undefined"!=typeof setImmediate?function(){setImmediate(i)}:function(){setTimeout(i,0)}})();return t=>{e.push(t),e.length-c==1&&r()}})();function o(t){if(!(this instanceof o))throw new TypeError("Zousan must be created with the new keyword");if("function"==typeof t){const e=this;try{t(t=>e.resolve(t),t=>e.reject(t))}catch(t){e.reject(t)}}else if(arguments.length>0)throw new TypeError("Zousan resolver "+t+" is not a function")}function c(e,n){if("function"==typeof e.y)try{const o=e.y.call(t,n);e.p.resolve(o)}catch(t){e.p.reject(t)}else e.p.resolve(n)}function i(e,n){if("function"==typeof e.n)try{const o=e.n.call(t,n);e.p.resolve(o)}catch(t){e.p.reject(t)}else e.p.reject(n)}o.prototype={resolve:function(t){if(this.state!==e)return;if(t===this)return this.reject(new TypeError("Attempt to resolve promise with self"));const o=this;if(t&&("function"==typeof t||"object"==typeof t)){let e=!0;try{const n=t.then;if("function"==typeof n)return void n.call(t,function(t){e&&(e=!1,o.resolve(t))},function(t){e&&(e=!1,o.reject(t))})}catch(t){return void(e&&this.reject(t))}}this.state="fulfilled",this.v=t,o.c&&n(function(){for(let e=0,n=o.c.length;e<n;e++)c(o.c[e],t)})},reject:function(t){if(this.state!==e)return;const c=this;this.state="rejected",this.v=t;const r=this.c;n(r?function(){for(let e=0,n=r.length;e<n;e++)i(r[e],t)}:function(){c.handled||o.suppressUncaughtRejectionError||o.warn("You upset Zousan. Please catch rejections: ",t,t?t.stack:null)})},then:function(t,r){const s=new o,f={y:t,n:r,p:s};if(this.state===e)this.c?this.c.push(f):this.c=[f];else{const t=this.state,e=this.v;this.handled=!0,n(function(){"fulfilled"===t?c(f,e):i(f,e)})}return s},catch:function(t){return this.then(null,t)},finally:function(t){return this.then(t,t)},timeout:function(t,e){e=e||"Timeout";const n=this;return new o(function(o,c){setTimeout(function(){c(Error(e))},t),n.then(function(t){o(t)},function(t){c(t)})})}},o.resolve=(t=>new o(e=>e(t))),o.reject=function(t){const e=new o;return e.c=[],e.reject(t),e},o.all=function(t){const e=[],n=new o;let c=0;function i(i,r){i&&"function"==typeof i.then||(i=o.resolve(i)),i.then(function(o){e[r]=o,++c==t.length&&n.resolve(e)},function(t){n.reject(t)})}for(let e=0;e<t.length;e++)i(t[e],e);return t.length||n.resolve(e),n};const r=()=>{};return o.warn="undefined"!=typeof console?console.warn:r,o.error="undefined"!=typeof console?console.error:r,o.soon=n,o});
